esphome:
  name: ha-arcade-panel
  friendly_name: HA Arcade Panel
  on_boot:
    priority: -100
    then:
      - display.page.show: page_time
      - lambda: |-
          id(display_mode) = 0;

esp32:
  board: lolin32
  framework:
    type: arduino

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: "cujoandcoqueta"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # Enable fallback hotspot in case WiFi connection fails
  ap:
    ssid: "HA-Arcade-Panel"
    password: !secret ap_password 

captive_portal:

# Global variables for display management
globals:
  - id: display_mode
    type: int
    restore_value: no
    initial_value: '0'  # 0=time, 1=temp, 2=custom
  - id: custom_text
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: text_duration
    type: int
    restore_value: no
    initial_value: '5000'
  - id: text_font_size
    type: int
    restore_value: no
    initial_value: '1'  # 1=small, 2=medium, 3=large
  - id: text_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: scroll_offset
    type: int
    restore_value: no
    initial_value: '0'
  - id: scroll_speed
    type: int
    restore_value: no
    initial_value: '3'

# I2C Bus for OLED Display
i2c:
  sda: GPIO21
  scl: GPIO22
  scan: true
  id: bus_a

# Fonts for display
font:
  - file: "gfonts://Roboto"
    id: font_small
    size: 12
  - file: "gfonts://Roboto"
    id: font_medium
    size: 16
  - file: "gfonts://Roboto"
    id: font_large
    size: 24
  - file: "gfonts://Roboto"
    id: font_time
    size: 28

# 1.3" OLED Display (SH1106 or SSD1306)
display:
  - platform: ssd1306_i2c
    model: "SH1106 128x64"  # Change to SSD1306_128X64 if using SSD1306
    id: display_page
    address: 0x3C  # Standard address - check I2C scan logs for actual address
    update_interval: 100ms  # Fast refresh for smooth text scrolling
    pages:
      - id: page_time
        lambda: |-
          it.strftime(64, 20, id(font_time), TextAlign::CENTER, "%H:%M", id(ha_time).now());
          it.strftime(64, 45, id(font_small), TextAlign::CENTER, "%d %b %Y", id(ha_time).now());
      
      - id: page_temp
        lambda: |-
          it.printf(64, 10, id(font_medium), TextAlign::CENTER, "Temperature");
          if (id(dht_temperature).has_state()) {
            it.printf(64, 30, id(font_large), TextAlign::CENTER, "%.1f°C", id(dht_temperature).state);
          }
          if (id(dht_humidity).has_state()) {
            it.printf(64, 52, id(font_small), TextAlign::CENTER, "Humidity: %.0f%%", id(dht_humidity).state);
          }
      
      - id: page_custom
        lambda: |-
          // Check if custom text display duration has expired (convert seconds to ms)
          if (millis() - id(text_start_time) > (id(text_duration) * 1000)) {
            id(display_mode) = 0;
            id(scroll_offset) = 0;
            return;
          }
          
          // Select font based on text_font_size
          auto font = id(font_small);
          if (id(text_font_size) == 2) font = id(font_medium);
          else if (id(text_font_size) == 3) font = id(font_large);
          
          // Measure text width
          int x1 = 0, y1 = 0, text_width = 0, text_height = 0;
          it.get_text_bounds(0, 0, id(custom_text).c_str(), font, TextAlign::TOP_LEFT, &x1, &y1, &text_width, &text_height);
          
          // If text fits on screen, center it
          if (text_width <= 128) {
            it.printf(64, 32, font, TextAlign::CENTER, "%s", id(custom_text).c_str());
            id(scroll_offset) = 0;
          } else {
            // Scroll text from right to left
            int x_pos = 128 - id(scroll_offset);
            it.printf(x_pos, 32, font, TextAlign::TOP_LEFT, "%s", id(custom_text).c_str());
            
            // Update scroll offset (moves scroll_speed pixels per update)
            id(scroll_offset) += id(scroll_speed);
            
            // Reset when text has scrolled off screen
            if (id(scroll_offset) > text_width + 128) {
              id(scroll_offset) = 0;
            }
          }

# Time component for display
time:
  - platform: homeassistant
    id: ha_time
    timezone: "America/New_York"  # Change to your timezone

# Interval to cycle between display pages
interval:
  - interval: 5s
    then:
      - lambda: |-
          if (id(display_mode) == 0) {
            // Switch from time to temperature
            id(display_page).show_page(id(page_temp));
            id(display_mode) = 1;
          } else if (id(display_mode) == 1) {
            // Switch from temperature to time
            id(display_page).show_page(id(page_time));
            id(display_mode) = 0;
          }
          // mode 2 (custom text) doesn't auto-cycle

# DHT22 Temperature and Humidity Sensor
sensor:
  - platform: dht
    pin: GPIO04
    model: DHT22
    temperature:
      name: "Arcade Panel Temperature"
      id: dht_temperature
      accuracy_decimals: 1
      filters:
        - offset: 0.0  # Calibration offset if needed
    humidity:
      name: "Arcade Panel Humidity"
      id: dht_humidity
      accuracy_decimals: 0
    update_interval: 30s
  
  # Heat Index (calculated from temp and humidity)
  - platform: template
    name: "Arcade Panel Heat Index"
    lambda: |-
      if (id(dht_temperature).has_state() && id(dht_humidity).has_state()) {
        float temp = id(dht_temperature).state;
        float hum = id(dht_humidity).state;
        // Heat index calculation (Fahrenheit based, convert C to F)
        float tempF = temp * 9.0 / 5.0 + 32.0;
        float hi = -42.379 + 2.04901523*tempF + 10.14333127*hum - 0.22475541*tempF*hum;
        hi += -0.00683783*tempF*tempF - 0.05481717*hum*hum + 0.00122874*tempF*tempF*hum;
        hi += 0.00085282*tempF*hum*hum - 0.00000199*tempF*tempF*hum*hum;
        // Convert back to Celsius
        return (hi - 32.0) * 5.0 / 9.0;
      }
      return 0.0;
    unit_of_measurement: "°C"
    update_interval: 30s
  
  # Dew Point (calculated)
  - platform: template
    name: "Arcade Panel Dew Point"
    lambda: |-
      if (id(dht_temperature).has_state() && id(dht_humidity).has_state()) {
        float temp = id(dht_temperature).state;
        float hum = id(dht_humidity).state;
        float a = 17.27;
        float b = 237.7;
        float alpha = ((a * temp) / (b + temp)) + log(hum/100.0);
        return (b * alpha) / (a - alpha);
      }
      return 0.0;
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: 30s
  
  # WiFi Signal Strength
  - platform: wifi_signal
    name: "Arcade Panel WiFi Signal"
    update_interval: 60s
    entity_category: "diagnostic"

  
  # Uptime sensor
  - platform: uptime
    name: "Arcade Panel Uptime"
    update_interval: 60s
    entity_category: "diagnostic"
  
  # Free heap memory
  - platform: internal_temperature
    name: "ESP32 Internal Temperature"
    update_interval: 60s
    entity_category: "diagnostic"

# Text Sensors
text_sensor:
  # Hardware Version
  - platform: template
    name: "Hardware Version"
    id: hardware_version
    icon: "mdi:chip"
    lambda: |-
      return {"HA Deck 1.0"};
    entity_category: "diagnostic"
  
  # IP Address
  - platform: wifi_info
    ip_address:
      name: "IP Address"
      icon: "mdi:ip-network"
      entity_category: "diagnostic"
    mac_address:
      name: "MAC Address"
      icon: "mdi:network-outline"
      entity_category: "diagnostic"

# Binary Sensors - Buttons with internal pull-ups
binary_sensor:
  # Blue Button
  - platform: gpio
    pin:
      number: GPIO17
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Blue Button"
    id: button_blue
    on_press:
      then:
        - light.toggle: led_blue
        - output.set_level:
            id: buzzer_output
            level: 50%
        - output.ledc.set_frequency:
            id: buzzer_output
            frequency: 2000Hz
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # Green Button
  - platform: gpio
    pin:
      number: GPIO19
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Green Button"
    id: button_green
    on_press:
      then:
        - light.toggle: led_green
        - output.set_level:
            id: buzzer_output
            level: 50%
        - output.ledc.set_frequency:
            id: buzzer_output
            frequency: 2200Hz
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # Red Button
  - platform: gpio
    pin:
      number: GPIO33
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Red Button"
    id: button_red
    on_press:
      then:
        - light.toggle: led_red
        - output.set_level:
            id: buzzer_output
            level: 50%
        - output.ledc.set_frequency:
            id: buzzer_output
            frequency: 2400Hz
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # White Button
  - platform: gpio
    pin:
      number: GPIO26
      mode:
        input: true
        pullup: true
      inverted: true
    name: "White Button"
    id: button_white
    on_press:
      then:
        - light.toggle: led_white
        - output.set_level:
            id: buzzer_output
            level: 50%
        - output.ledc.set_frequency:
            id: buzzer_output
            frequency: 2600Hz
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # Yellow Button
  - platform: gpio
    pin:
      number: GPIO27
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Yellow Button"
    id: button_yellow
    on_press:
      then:
        - light.toggle: led_yellow
        - output.set_level:
            id: buzzer_output
            level: 50%
        - output.ledc.set_frequency:
            id: buzzer_output
            frequency: 2800Hz
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # RCWL-0516 Motion Sensor
  - platform: gpio
    pin: GPIO23
    name: "Arcade Panel Motion"
    device_class: motion
    id: motion_sensor

# Output for Buzzer (PWM for tone generation)
output:
  - platform: ledc
    pin: GPIO13
    id: buzzer_output
    frequency: 2000Hz

  # Status LED Output (GPIO2)
  - platform: gpio
    pin: GPIO2
    id: output_status

# LED Outputs
  - platform: gpio
    pin: GPIO16
    id: output_blue
  
  - platform: gpio
    pin: GPIO18
    id: output_green
  
  - platform: gpio
    pin: GPIO32
    id: output_red
  
  - platform: gpio
    pin: GPIO25
    id: output_white
  
  - platform: gpio
    pin: GPIO14
    id: output_yellow

# Light entities for LEDs
light:
  - platform: binary
    name: "LED 1 Blue"
    id: led_blue
    output: output_blue
    restore_mode: RESTORE_DEFAULT_OFF
  
  - platform: binary
    name: "LED 2 Green"
    id: led_green
    output: output_green
    restore_mode: RESTORE_DEFAULT_OFF
  
  - platform: binary
    name: "LED 3 Red"
    id: led_red
    output: output_red
    restore_mode: RESTORE_DEFAULT_OFF
  
  - platform: binary
    name: "LED 4 White"
    id: led_white
    output: output_white
    restore_mode: RESTORE_DEFAULT_OFF
  
  - platform: binary
    name: "LED 5 Yellow"
    id: led_yellow
    output: output_yellow
    restore_mode: RESTORE_DEFAULT_OFF
  
  - platform: binary
    name: "LED 6 Status"
    id: led_status
    output: output_status
    restore_mode: RESTORE_DEFAULT_OFF

# Text inputs for custom display messages
text:
  - platform: template
    name: "Display A Message"
    id: display_message_input
    optimistic: true
    min_length: 0
    max_length: 100
    mode: text
    on_value:
      then:
        - lambda: |-
            id(custom_text) = x;
            id(text_start_time) = millis();
            id(display_mode) = 2;
        - display.page.show: page_custom

# Number inputs for display control
number:
  - platform: template
    name: "Display C Duration"
    id: display_duration_input
    optimistic: true
    min_value: 1
    max_value: 300
    step: 1
    initial_value: 30
    unit_of_measurement: "s"
    mode: box
    on_value:
      then:
        - lambda: |-
            id(text_duration) = x;
  
  - platform: template
    name: "Display D Scroll Speed"
    id: scroll_speed_input
    optimistic: true
    min_value: 20
    max_value: 100
    step: 1
    initial_value: 3
    unit_of_measurement: "px/s"
    mode: slider
    on_value:
      then:
        - lambda: |-
            id(scroll_speed) = x;

# Select inputs for display and buzzer control
select:
  # Font size selector
  - platform: template
    name: "Display B Font Size"
    id: font_size_select
    optimistic: true
    options:
      - "Small"
      - "Medium"
      - "Large"
    initial_option: "Small"
    on_value:
      then:
        - lambda: |-
            if (x == "Small") id(text_font_size) = 1;
            else if (x == "Medium") id(text_font_size) = 2;
            else if (x == "Large") id(text_font_size) = 3;
  
  # Buzzer pattern selector
  - platform: template
    name: "Buzzer Pattern"
    id: buzzer_pattern_select
    optimistic: true
    options:
      - "None"
      - "Short Beep"
      - "Beep-Beep"
      - "Long Beep"
      - "Triple Beep"
      - "Rising Tone"
      - "Alert Pattern"
      - "Success Chirp"
      - "Error Buzz"
      - "Doorbell"
      - "SOS Pattern"
    initial_option: "None"
    on_value:
      then:
        - if:
            condition:
              lambda: 'return x == "Short Beep";'
            then:
              # C note (523 Hz)
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 523Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return x == "Beep-Beep";'
            then:
              # Two E notes (659 Hz)
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 659Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return x == "Long Beep";'
            then:
              # Low A note (440 Hz)
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 440Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 500ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return x == "Triple Beep";'
            then:
              # C-E-G chord progression
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 523Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 659Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 784Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return x == "Rising Tone";'
            then:
              # Rising scale: C-D-E
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 523Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 150ms
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 587Hz
              - delay: 150ms
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 659Hz
              - delay: 150ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return x == "Alert Pattern";'
            then:
              # Alternating high-low tones
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 800Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 200ms
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 600Hz
              - delay: 200ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 800Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 200ms
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 600Hz
              - delay: 200ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return x == "Success Chirp";'
            then:
              # G-C happy chirp
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 784Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 50ms
              - output.turn_off: buzzer_output
              - delay: 50ms
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 1047Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return x == "Error Buzz";'
            then:
              # Low buzz (200 Hz)
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 200Hz
              - output.set_level:
                  id: buzzer_output
                  level: 70%
              - delay: 400ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return x == "Doorbell";'
            then:
              # Ding-dong (E-C)
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 659Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 150ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 523Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 150ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return x == "SOS Pattern";'
            then:
              # SOS in morse: ... --- ...
              # Short beeps (S)
              - output.ledc.set_frequency:
                  id: buzzer_output
                  frequency: 800Hz
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 200ms
              # Long beeps (O)
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 300ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 300ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 300ms
              - output.turn_off: buzzer_output
              - delay: 200ms
              # Short beeps (S)
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.set_level:
                  id: buzzer_output
                  level: 50%
              - delay: 100ms
              - output.turn_off: buzzer_output
