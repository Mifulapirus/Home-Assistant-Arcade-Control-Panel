esphome:
  name: ha-arcade-panel
  friendly_name: HA Arcade Panel
  platform: ESP32
  board: nodemcu-32s
  on_boot:
    priority: -100
    then:
      - display.page.show: page_time
      - lambda: |-
          id(display_mode) = 0;

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key
  services:
    # Service to display custom text on screen
    - service: display_text
      variables:
        text: string
        duration: int
        font_size: int
      then:
        - lambda: |-
            id(custom_text) = text;
            id(text_duration) = duration;
            id(text_font_size) = font_size;
            id(display_mode) = 2; // Custom text mode
            id(text_start_time) = millis();
        - display.page.show: page_custom
    
    # Service to play buzzer sequences
    - service: play_buzzer_sequence
      variables:
        sequence: int
      then:
        - if:
            condition:
              lambda: 'return sequence == 1;'
            then:
              # Short beep
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return sequence == 2;'
            then:
              # Beep-Beep
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return sequence == 3;'
            then:
              # Long beep
              - output.turn_on: buzzer_output
              - delay: 500ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return sequence == 4;'
            then:
              # Triple beep
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return sequence == 5;'
            then:
              # Rising tone (simulated with delays)
              - output.turn_on: buzzer_output
              - delay: 50ms
              - output.turn_off: buzzer_output
              - delay: 25ms
              - output.turn_on: buzzer_output
              - delay: 50ms
              - output.turn_off: buzzer_output
              - delay: 25ms
              - output.turn_on: buzzer_output
              - delay: 50ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return sequence == 6;'
            then:
              # Alert pattern
              - output.turn_on: buzzer_output
              - delay: 200ms
              - output.turn_off: buzzer_output
              - delay: 200ms
              - output.turn_on: buzzer_output
              - delay: 200ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return sequence == 7;'
            then:
              # Success chirp
              - output.turn_on: buzzer_output
              - delay: 50ms
              - output.turn_off: buzzer_output
              - delay: 50ms
              - output.turn_on: buzzer_output
              - delay: 50ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return sequence == 8;'
            then:
              # Error buzz
              - output.turn_on: buzzer_output
              - delay: 800ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return sequence == 9;'
            then:
              # Doorbell
              - output.turn_on: buzzer_output
              - delay: 150ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 150ms
              - output.turn_off: buzzer_output
        - if:
            condition:
              lambda: 'return sequence == 10;'
            then:
              # SOS pattern (... --- ...)
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 200ms
              - output.turn_on: buzzer_output
              - delay: 300ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 300ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 300ms
              - output.turn_off: buzzer_output
              - delay: 200ms
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output
              - delay: 100ms
              - output.turn_on: buzzer_output
              - delay: 100ms
              - output.turn_off: buzzer_output

ota:
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # Enable fallback hotspot in case WiFi connection fails
  ap:
    ssid: "HA-Arcade-Panel"
    password: !secret ap_password

captive_portal:

# Global variables for display management
globals:
  - id: display_mode
    type: int
    restore_value: no
    initial_value: '0'  # 0=time, 1=temp, 2=custom
  - id: custom_text
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: text_duration
    type: int
    restore_value: no
    initial_value: '5000'
  - id: text_font_size
    type: int
    restore_value: no
    initial_value: '1'  # 1=small, 2=medium, 3=large
  - id: text_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

# I2C Bus for OLED Display
i2c:
  sda: GPIO21
  scl: GPIO22
  scan: true
  id: bus_a

# Fonts for display
font:
  - file: "gfonts://Roboto"
    id: font_small
    size: 12
  - file: "gfonts://Roboto"
    id: font_medium
    size: 16
  - file: "gfonts://Roboto"
    id: font_large
    size: 24
  - file: "gfonts://Roboto"
    id: font_time
    size: 28

# 1.3" OLED Display (SH1106 or SSD1306)
display:
  - platform: ssd1306_i2c
    model: "SH1106 128x64"  # Change to SSD1306_128X64 if using SSD1306
    address: 0x3C
    update_interval: 1s
    pages:
      - id: page_time
        lambda: |-
          it.strftime(64, 20, id(font_time), TextAlign::CENTER, "%H:%M", id(ha_time).now());
          it.strftime(64, 45, id(font_small), TextAlign::CENTER, "%d %b %Y", id(ha_time).now());
      
      - id: page_temp
        lambda: |-
          it.printf(64, 10, id(font_medium), TextAlign::CENTER, "Temperature");
          if (id(dht_temperature).has_state()) {
            it.printf(64, 30, id(font_large), TextAlign::CENTER, "%.1f°C", id(dht_temperature).state);
          }
          if (id(dht_humidity).has_state()) {
            it.printf(64, 52, id(font_small), TextAlign::CENTER, "Humidity: %.0f%%", id(dht_humidity).state);
          }
      
      - id: page_custom
        lambda: |-
          // Check if custom text display duration has expired
          if (millis() - id(text_start_time) > id(text_duration)) {
            id(display_mode) = 0;
            return;
          }
          
          // Select font based on text_font_size
          auto font = id(font_small);
          if (id(text_font_size) == 2) font = id(font_medium);
          else if (id(text_font_size) == 3) font = id(font_large);
          
          it.printf(64, 32, font, TextAlign::CENTER, "%s", id(custom_text).c_str());

# Time component for display
time:
  - platform: homeassistant
    id: ha_time
    timezone: "America/New_York"  # Change to your timezone

# Interval to cycle between display pages
interval:
  - interval: 5s
    then:
      - lambda: |-
          if (id(display_mode) == 0) {
            // Switch from time to temperature
            id(display_page)->show_next();
            id(display_mode) = 1;
          } else if (id(display_mode) == 1) {
            // Switch from temperature to time
            id(display_page)->show_next();
            id(display_mode) = 0;
          }
          // mode 2 (custom text) doesn't auto-cycle

# DHT22 Temperature and Humidity Sensor
sensor:
  - platform: dht
    pin: GPIO04
    model: DHT22
    temperature:
      name: "Arcade Panel Temperature"
      id: dht_temperature
      accuracy_decimals: 1
      filters:
        - offset: 0.0  # Calibration offset if needed
    humidity:
      name: "Arcade Panel Humidity"
      id: dht_humidity
      accuracy_decimals: 0
    update_interval: 30s
  
  # Heat Index (calculated from temp and humidity)
  - platform: template
    name: "Arcade Panel Heat Index"
    lambda: |-
      if (id(dht_temperature).has_state() && id(dht_humidity).has_state()) {
        float temp = id(dht_temperature).state;
        float hum = id(dht_humidity).state;
        // Heat index calculation (Fahrenheit based, convert C to F)
        float tempF = temp * 9.0 / 5.0 + 32.0;
        float hi = -42.379 + 2.04901523*tempF + 10.14333127*hum - 0.22475541*tempF*hum;
        hi += -0.00683783*tempF*tempF - 0.05481717*hum*hum + 0.00122874*tempF*tempF*hum;
        hi += 0.00085282*tempF*hum*hum - 0.00000199*tempF*tempF*hum*hum;
        // Convert back to Celsius
        return (hi - 32.0) * 5.0 / 9.0;
      }
      return 0.0;
    unit_of_measurement: "°C"
    update_interval: 30s
  
  # Dew Point (calculated)
  - platform: template
    name: "Arcade Panel Dew Point"
    lambda: |-
      if (id(dht_temperature).has_state() && id(dht_humidity).has_state()) {
        float temp = id(dht_temperature).state;
        float hum = id(dht_humidity).state;
        float a = 17.27;
        float b = 237.7;
        float alpha = ((a * temp) / (b + temp)) + log(hum/100.0);
        return (b * alpha) / (a - alpha);
      }
      return 0.0;
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: 30s
  
  # WiFi Signal Strength
  - platform: wifi_signal
    name: "Arcade Panel WiFi Signal"
    update_interval: 60s

# Binary Sensors - Buttons with internal pull-ups
binary_sensor:
  # Blue Button
  - platform: gpio
    pin:
      number: GPIO17
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Blue Button"
    id: button_blue
    on_press:
      then:
        - light.toggle: led_blue
        - output.turn_on: buzzer_output
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # Green Button
  - platform: gpio
    pin:
      number: GPIO19
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Green Button"
    id: button_green
    on_press:
      then:
        - light.toggle: led_green
        - output.turn_on: buzzer_output
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # Red Button
  - platform: gpio
    pin:
      number: GPIO33
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Red Button"
    id: button_red
    on_press:
      then:
        - light.toggle: led_red
        - output.turn_on: buzzer_output
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # White Button
  - platform: gpio
    pin:
      number: GPIO26
      mode:
        input: true
        pullup: true
      inverted: true
    name: "White Button"
    id: button_white
    on_press:
      then:
        - light.toggle: led_white
        - output.turn_on: buzzer_output
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # Yellow Button
  - platform: gpio
    pin:
      number: GPIO27
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Yellow Button"
    id: button_yellow
    on_press:
      then:
        - light.toggle: led_yellow
        - output.turn_on: buzzer_output
        - delay: 50ms
        - output.turn_off: buzzer_output
  
  # RCWL-0516 Motion Sensor
  - platform: gpio
    pin: GPIO23
    name: "Arcade Panel Motion"
    device_class: motion
    id: motion_sensor

# Output for Buzzer
output:
  - platform: gpio
    pin: GPIO13
    id: buzzer_output

# LED Outputs
  - platform: gpio
    pin: GPIO16
    id: output_blue
  
  - platform: gpio
    pin: GPIO18
    id: output_green
  
  - platform: gpio
    pin: GPIO32
    id: output_red
  
  - platform: gpio
    pin: GPIO25
    id: output_white
  
  - platform: gpio
    pin: GPIO14
    id: output_yellow

# Light entities for LEDs
light:
  - platform: binary
    name: "Blue LED"
    id: led_blue
    output: output_blue
    restore_mode: RESTORE_DEFAULT_OFF
  
  - platform: binary
    name: "Green LED"
    id: led_green
    output: output_green
    restore_mode: RESTORE_DEFAULT_OFF
  
  - platform: binary
    name: "Red LED"
    id: led_red
    output: output_red
    restore_mode: RESTORE_DEFAULT_OFF
  
  - platform: binary
    name: "White LED"
    id: led_white
    output: output_white
    restore_mode: RESTORE_DEFAULT_OFF
  
  - platform: binary
    name: "Yellow LED"
    id: led_yellow
    output: output_yellow
    restore_mode: RESTORE_DEFAULT_OFF

# Status LED (optional - uses onboard LED)
status_led:
  pin:
    number: GPIO2
    inverted: false
